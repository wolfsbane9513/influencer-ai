# agents/enhanced_contracts.py
import uuid
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional

from models.campaign import CampaignData, NegotiationState, Creator
from agents.enhanced_negotiation import NegotiationResultValidator

logger = logging.getLogger(__name__)

class EnhancedContractAgent:
    """
    📝 ENHANCED CONTRACT AGENT
    Generates contracts using structured negotiation data from ElevenLabs analysis
    """
    
    def __init__(self):
        self.validator = NegotiationResultValidator()
        self.contract_templates = self._load_enhanced_templates()
    
    def _load_enhanced_templates(self) -> Dict[str, str]:
        """Load enhanced contract templates"""
        return {
            "premium": """
PREMIUM INFLUENCER MARKETING AGREEMENT

Contract ID: {contract_id}
Campaign: {campaign_name}
Date: {contract_date}

PARTIES:
Brand: {brand_name}
Address: [Brand Address]
Email: partnerships@{brand_domain}

Influencer: {creator_name}
Platform: {creator_platform}
Email: {creator_email}
Phone: {creator_phone}

COLLABORATION DETAILS:
Campaign: {campaign_name}
Product: {product_name}
Target Launch: {campaign_launch_date}

COMPENSATION & TERMS:
Total Compensation: ${final_rate:,.2f}
Payment Schedule: {payment_schedule}
Payment Method: Bank transfer / Digital payment

DELIVERABLES & SPECIFICATIONS:
{deliverable_specifications}

TIMELINE & MILESTONES:
{timeline_details}

USAGE RIGHTS & LICENSING:
{usage_rights_details}

PERFORMANCE METRICS & SUCCESS CRITERIA:
{performance_criteria}

CONTENT GUIDELINES & APPROVAL:
{content_guidelines}

LEGAL & COMPLIANCE:
{legal_requirements}

ADDITIONAL TERMS:
{additional_terms}

This agreement represents the complete understanding between parties and supersedes all prior negotiations.

SIGNATURES:
Brand Representative: _________________ Date: _________
Influencer: _________________ Date: _________

Generated by InfluencerFlow AI Platform
Contract ID: {contract_id}
Generated: {generation_timestamp}
""",
            "standard": """
INFLUENCER MARKETING AGREEMENT

Contract ID: {contract_id}
Date: {contract_date}

BRAND: {brand_name}
INFLUENCER: {creator_name} ({creator_platform})
CAMPAIGN: {campaign_name}

COMPENSATION: ${final_rate:,.2f}
PAYMENT: {payment_schedule}

DELIVERABLES:
{deliverable_list}

TIMELINE: {timeline}
USAGE RIGHTS: {usage_rights}

CONTENT APPROVAL:
- Brand reviews content draft within 24 hours
- Up to 2 minor revisions included
- Final approval required before posting

LEGAL COMPLIANCE:
- FTC disclosure requirements apply (#ad, #sponsored)
- Brand safety guidelines must be followed
- Creator maintains editorial control within brand guidelines

CANCELLATION: 48 hours notice, 50% payment if cancelled after approval

Contract ID: {contract_id}
Generated: {generation_timestamp}

Brand: _________________ Date: _______
Influencer: _________________ Date: _______
"""
        }
    
    async def generate_enhanced_contract(
        self,
        negotiation_state: NegotiationState,
        campaign_data: CampaignData,
        creator_data: Optional[Creator] = None
    ) -> Dict[str, Any]:
        """
        📝 Generate enhanced contract using structured negotiation data
        """
        
        # STEP 1: Validate negotiation results
        validation_result = self.validator.validate_negotiation_result(negotiation_state)
        
        if not validation_result["is_valid"]:
            raise ValueError(f"Invalid negotiation data: {validation_result['errors']}")
        
        if validation_result["warnings"]:
            logger.warning(f"Contract generation warnings: {validation_result['warnings']}")
        
        # STEP 2: Generate contract ID and basic info
        contract_id = f"IFC-{str(uuid.uuid4())[:8].upper()}"
        
        logger.info(f"📝 Generating enhanced contract {contract_id} for {negotiation_state.creator_id}")
        
        # STEP 3: Prepare comprehensive contract data
        contract_data = await self._prepare_enhanced_contract_data(
            negotiation_state, campaign_data, creator_data, contract_id
        )
        
        # STEP 4: Select template based on contract value and complexity
        template_type = self._select_contract_template(negotiation_state.final_rate)
        
        # STEP 5: Generate contract content
        contract_content = self._generate_enhanced_contract_content(contract_data, template_type)
        
        # STEP 6: Create detailed contract record
        contract_record = {
            "contract_id": contract_id,
            "campaign_id": campaign_data.id,
            "creator_id": negotiation_state.creator_id,
            "negotiation_id": negotiation_state.conversation_id,
            
            # Financial terms
            "final_rate": negotiation_state.final_rate,
            "payment_schedule": self._create_detailed_payment_schedule(negotiation_state),
            "currency": "USD",
            
            # Contract content and terms
            "contract_content": contract_content,
            "negotiated_terms": negotiation_state.negotiated_terms,
            "deliverables": self._format_enhanced_deliverables(negotiation_state.negotiated_terms),
            
            # Timeline and milestones
            "timeline": self._create_detailed_timeline(negotiation_state.negotiated_terms),
            "milestones": self._create_milestone_tracking(negotiation_state),
            
            # Legal and compliance
            "usage_rights": self._format_usage_rights(negotiation_state.negotiated_terms),
            "compliance_requirements": self._get_compliance_requirements(),
            
            # Status and tracking
            "status": "draft",
            "template_type": template_type,
            "validation_result": validation_result,
            
            # Timestamps
            "created_at": datetime.now().isoformat(),
            "execution_date": (datetime.now() + timedelta(days=1)).isoformat(),
            "content_due_date": self._calculate_content_due_date(negotiation_state.negotiated_terms),
            "campaign_end_date": (datetime.now() + timedelta(days=30)).isoformat(),
            
            # Metadata
            "generation_metadata": {
                "negotiation_source": "elevenlabs_analysis",
                "analysis_confidence": negotiation_state.negotiated_terms.get("analysis_confidence", 0.8),
                "creator_enthusiasm": negotiation_state.negotiated_terms.get("creator_enthusiasm", 5),
                "contract_complexity": template_type,
                "auto_generated": True
            }
        }
        
        logger.info(f"✅ Enhanced contract {contract_id} generated successfully")
        logger.info(f"📊 Contract value: ${negotiation_state.final_rate:,.2f} | Template: {template_type}")
        
        return contract_record
    
    async def _prepare_enhanced_contract_data(
        self,
        negotiation_state: NegotiationState,
        campaign_data: CampaignData,
        creator_data: Optional[Creator],
        contract_id: str
    ) -> Dict[str, Any]:
        """Prepare comprehensive contract data"""
        
        negotiated_terms = negotiation_state.negotiated_terms
        
        # Basic contract information
        contract_data = {
            "contract_id": contract_id,
            "contract_date": datetime.now().strftime("%Y-%m-%d"),
            "generation_timestamp": datetime.now().isoformat(),
            
            # Campaign information
            "campaign_name": f"{campaign_data.product_name} Campaign",
            "brand_name": campaign_data.brand_name,
            "brand_domain": campaign_data.brand_name.lower().replace(" ", ""),
            "product_name": campaign_data.product_name,
            "product_description": campaign_data.product_description,
            "campaign_goal": campaign_data.campaign_goal,
            "campaign_launch_date": (datetime.now() + timedelta(days=7)).strftime("%Y-%m-%d"),
            
            # Creator information
            "creator_name": creator_data.name if creator_data else negotiation_state.creator_id,
            "creator_platform": creator_data.platform.value if creator_data else "Social Media",
            "creator_email": f"{negotiation_state.creator_id}@example.com",  # Would be looked up
            "creator_phone": creator_data.phone_number if creator_data else "TBD",
            
            # Financial terms
            "final_rate": negotiation_state.final_rate,
            "payment_schedule": negotiated_terms.get("payment_schedule", "50% upfront, 50% on delivery"),
            
            # Content terms
            "timeline": negotiated_terms.get("timeline", "7 days"),
            "usage_rights": negotiated_terms.get("usage_rights", "organic_only"),
            "deliverables": negotiated_terms.get("deliverables", []),
            
            # Enhanced details
            "creator_enthusiasm": negotiated_terms.get("creator_enthusiasm", 5),
            "key_quotes": negotiated_terms.get("key_quotes", []),
            "conversation_summary": negotiated_terms.get("negotiation_notes", ""),
        }
        
        # Generate detailed sections
        contract_data.update({
            "deliverable_specifications": self._generate_deliverable_specifications(negotiated_terms),
            "timeline_details": self._generate_timeline_details(negotiated_terms),
            "usage_rights_details": self._generate_usage_rights_details(negotiated_terms),
            "performance_criteria": self._generate_performance_criteria(campaign_data, creator_data),
            "content_guidelines": self._generate_content_guidelines(campaign_data),
            "legal_requirements": self._generate_legal_requirements(),
            "additional_terms": self._generate_additional_terms(negotiated_terms),
            "deliverable_list": self._format_deliverable_list(negotiated_terms.get("deliverables", []))
        })
        
        return contract_data
    
    def _select_contract_template(self, final_rate: float) -> str:
        """Select appropriate contract template based on value"""
        if final_rate >= 5000:
            return "premium"
        else:
            return "standard"
    
    def _generate_enhanced_contract_content(self, contract_data: Dict[str, Any], template_type: str) -> str:
        """Generate the actual contract content"""
        template = self.contract_templates[template_type]
        return template.format(**contract_data)
    
    def _generate_deliverable_specifications(self, negotiated_terms: Dict[str, Any]) -> str:
        """Generate detailed deliverable specifications"""
        
        deliverables = negotiated_terms.get("deliverables", [])
        
        specs = []
        for deliverable in deliverables:
            if deliverable == "video_review":
                specs.append("""
1. PRODUCT REVIEW VIDEO
   - Duration: 2-5 minutes
   - Quality: 1080p minimum, professional lighting preferred
   - Content: Honest product demonstration and opinion
   - Include: Unboxing, key features showcase, personal experience
   - Format: Platform-appropriate (vertical for TikTok/Instagram, horizontal for YouTube)
   - Deadline: Within agreed timeline""")
            
            elif deliverable == "instagram_post":
                specs.append("""
2. INSTAGRAM FEED POST
   - High-quality images or video showcasing product
   - Engaging caption (100-250 words) with authentic brand integration
   - Required hashtags: #ad #sponsored + relevant product/brand tags
   - Tag brand account (@brandname)
   - Stories crosspost encouraged""")
            
            elif deliverable == "instagram_story":
                specs.append("""
3. INSTAGRAM STORY SERIES
   - 3-5 story slides featuring product
   - Mix of behind-the-scenes and product showcase content
   - Interactive elements encouraged (polls, questions, swipe-ups)
   - Brand tag and relevant hashtags
   - 24-hour highlight save recommended""")
        
        return "\n".join(specs) if specs else "Deliverables to be specified in final agreement"
    
    def _generate_timeline_details(self, negotiated_terms: Dict[str, Any]) -> str:
        """Generate detailed timeline with milestones"""
        
        timeline = negotiated_terms.get("timeline", "7 days")
        
        return f"""
CONTENT CREATION TIMELINE: {timeline}

MILESTONE SCHEDULE:
• Contract Execution: Within 24 hours of agreement
• Content Brief & Assets: Brand provides within 48 hours
• Draft Content Review: Creator submits draft within {timeline}
• Brand Feedback: Within 24 hours of draft submission
• Final Content Delivery: Within 48 hours of approval
• Content Publishing: Coordinated schedule with brand team
• Performance Reporting: 7 days post-publication

COMMUNICATION:
- Primary contact via email and platform messaging
- 24-hour response time for urgent requests
- Weekly check-ins for campaigns longer than 2 weeks
"""
    
    def _generate_usage_rights_details(self, negotiated_terms: Dict[str, Any]) -> str:
        """Generate detailed usage rights section"""
        
        usage_rights = negotiated_terms.get("usage_rights", "organic_only")
        
        rights_details = {
            "organic_only": """
ORGANIC USAGE RIGHTS (12 months):
• Brand may repost content on official social media accounts with creator credit
• Use in organic social media posts and stories
• Website and blog integration with attribution
• Email marketing with creator permission
• NO paid advertising without additional compensation
• Creator retains all original rights and ownership""",
            
            "paid_ads": """
PAID ADVERTISING RIGHTS (6 months):
• All organic usage rights included
• Paid social media advertising across all platforms
• Boosted posts and sponsored content amplification
• Display advertising on brand website
• Performance-based ad optimization permitted
• Creator must be credited in all paid usage""",
            
            "commercial_use": """
FULL COMMERCIAL RIGHTS (12 months):
• Complete usage rights for marketing and advertising
• Print and digital advertising materials
• Product packaging and point-of-sale materials
• Trade show and event marketing materials
• Press releases and media kits
• Sublicensing to authorized partners with creator notification"""
        }
        
        return rights_details.get(usage_rights, rights_details["organic_only"])
    
    def _generate_performance_criteria(self, campaign_data: CampaignData, creator_data: Optional[Creator]) -> str:
        """Generate performance criteria and success metrics"""
        
        expected_engagement = creator_data.engagement_rate if creator_data else 4.0
        expected_views = creator_data.average_views if creator_data else 50000
        
        return f"""
PERFORMANCE EXPECTATIONS:
• Minimum engagement rate: {expected_engagement:.1f}% (based on creator's average)
• Expected reach: {expected_views:,}+ views/impressions
• Content quality: Professional production standards
• Brand safety: 100% compliance with brand guidelines
• Audience authenticity: No purchased engagement or fake followers

SUCCESS METRICS:
• Engagement rate relative to creator's average performance
• Click-through rate to brand website/product pages
• Brand mention sentiment analysis
• Audience growth and quality metrics
• Content longevity and organic sharing

REPORTING:
Brand will provide performance analytics within 7 days of campaign completion including:
- Reach and impression data
- Engagement metrics breakdown
- Website traffic attribution
- Conversion tracking (where applicable)
"""
    
    def _generate_content_guidelines(self, campaign_data: CampaignData) -> str:
        """Generate content guidelines section"""
        
        return f"""
CONTENT GUIDELINES:

BRAND MESSAGING:
• Highlight key product benefits: {campaign_data.product_description}
• Target audience: {campaign_data.target_audience}
• Campaign goal: {campaign_data.campaign_goal}
• Brand voice: Authentic, relatable, and informative

CONTENT REQUIREMENTS:
• All content must be original and creator-generated
• Honest opinions and authentic experiences required
• Product must be prominently featured and demonstrated
• Clear, high-quality visuals in good lighting
• Audio quality must be clear and professional

APPROVAL PROCESS:
1. Creator submits content outline/storyboard for review
2. Brand provides feedback within 24 hours
3. Creator develops full content and submits for approval
4. Brand approves or requests minor revisions within 48 hours
5. Creator implements feedback and delivers final content
6. Posting schedule coordinated between both parties

BRAND SAFETY:
• No controversial, political, or sensitive topic content
• Family-friendly content appropriate for all audiences
• No competing brand mentions or products visible
• Compliance with platform community guidelines
• Professional representation of brand values
"""
    
    def _generate_legal_requirements(self) -> str:
        """Generate legal and compliance requirements"""
        
        return """
LEGAL & COMPLIANCE REQUIREMENTS:

FTC DISCLOSURE:
• Clear and conspicuous disclosure required (#ad, #sponsored, #partnership)
• Disclosure must be at the beginning of captions and visible in videos
• Verbal disclosure required in video content
• Platform-specific disclosure best practices must be followed

INTELLECTUAL PROPERTY:
• Creator retains ownership of original content
• Brand receives usage rights as specified in agreement
• No unauthorized use of brand trademarks or copyrighted material
• Creator responsible for music licensing and third-party content rights

LIABILITY & INDEMNIFICATION:
• Creator responsible for content accuracy and legal compliance
• Brand not liable for creator's other business activities
• Both parties maintain appropriate insurance coverage
• Mutual indemnification for respective responsibilities

CONFIDENTIALITY:
• Campaign details confidential until public launch
• Product information and marketing strategies protected
• Creator may not disclose financial terms publicly
• Non-disclosure period: 12 months post-campaign

FORCE MAJEURE:
Standard force majeure clauses apply for unforeseeable circumstances affecting performance.
"""
    
    def _generate_additional_terms(self, negotiated_terms: Dict[str, Any]) -> str:
        """Generate additional terms based on negotiation"""
        
        terms = []
        
        # Add terms based on negotiation analysis
        if negotiated_terms.get("creator_enthusiasm", 5) >= 8:
            terms.append("• Priority consideration for future brand collaborations")
        
        if "long-term partnership" in negotiated_terms.get("negotiation_notes", "").lower():
            terms.append("• Opportunity for ongoing partnership discussions")
        
        # Standard additional terms
        terms.extend([
            "• Content may be used for case studies and portfolio purposes (with creator permission)",
            "• Brand will provide product samples at no cost to creator",
            "• Creator agrees to professional and timely communication throughout campaign",
            "• Any material changes to campaign scope require written agreement from both parties",
            "• Governing law: [State/Country jurisdiction]",
            "• Dispute resolution: Good faith negotiation followed by binding arbitration if needed"
        ])
        
        return "\n".join(terms)
    
    def _format_deliverable_list(self, deliverables: List[str]) -> str:
        """Format deliverables for simple contract template"""
        if not deliverables:
            return "• Deliverables to be specified"
        
        formatted = []
        for deliverable in deliverables:
            formatted_name = deliverable.replace("_", " ").title()
            formatted.append(f"• {formatted_name}")
        
        return "\n".join(formatted)
    
    def _create_detailed_payment_schedule(self, negotiation_state: NegotiationState) -> List[Dict[str, Any]]:
        """Create detailed payment schedule with milestones"""
        
        final_rate = negotiation_state.final_rate
        payment_terms = negotiation_state.negotiated_terms.get("payment_schedule", "50% upfront, 50% on delivery")
        
        if "25%" in payment_terms and "50%" in payment_terms:
            # Three-part payment schedule
            return [
                {
                    "milestone": "Contract Execution",
                    "amount": final_rate * 0.25,
                    "percentage": 25,
                    "due_date": (datetime.now() + timedelta(days=1)).isoformat(),
                    "description": "25% payment upon contract signing",
                    "status": "pending"
                },
                {
                    "milestone": "Content Delivery",
                    "amount": final_rate * 0.50,
                    "percentage": 50,
                    "due_date": (datetime.now() + timedelta(days=8)).isoformat(),
                    "description": "50% payment upon content delivery and approval",
                    "status": "pending"
                },
                {
                    "milestone": "Content Published",
                    "amount": final_rate * 0.25,
                    "percentage": 25,
                    "due_date": (datetime.now() + timedelta(days=15)).isoformat(),
                    "description": "25% final payment after content is published",
                    "status": "pending"
                }
            ]
        elif "50%" in payment_terms:
            # Two-part payment schedule
            return [
                {
                    "milestone": "Contract Execution",
                    "amount": final_rate * 0.50,
                    "percentage": 50,
                    "due_date": (datetime.now() + timedelta(days=1)).isoformat(),
                    "description": "50% upfront payment upon contract signing",
                    "status": "pending"
                },
                {
                    "milestone": "Content Delivery",
                    "amount": final_rate * 0.50,
                    "percentage": 50,
                    "due_date": (datetime.now() + timedelta(days=8)).isoformat(),
                    "description": "50% final payment upon content delivery and approval",
                    "status": "pending"
                }
            ]
        else:
            # Single payment
            return [
                {
                    "milestone": "Content Delivery",
                    "amount": final_rate,
                    "percentage": 100,
                    "due_date": (datetime.now() + timedelta(days=8)).isoformat(),
                    "description": "Full payment upon content delivery and approval",
                    "status": "pending"
                }
            ]
    
    def _format_enhanced_deliverables(self, negotiated_terms: Dict[str, Any]) -> Dict[str, Any]:
        """Format deliverables with detailed specifications"""
        
        deliverables = negotiated_terms.get("deliverables", [])
        
        return {
            "primary_deliverables": deliverables,
            "total_count": len(deliverables),
            "specifications": {
                "quality_standards": "Professional production quality required",
                "approval_process": "Draft review → Feedback → Final delivery",
                "revision_policy": "Up to 2 minor revisions included",
                "format_requirements": "Platform-appropriate formats and dimensions",
                "timeline_per_deliverable": negotiated_terms.get("timeline", "7 days")
            },
            "compliance_requirements": {
                "ftc_disclosure": "Required for all content",
                "brand_guidelines": "Must follow provided brand guidelines",
                "platform_policies": "Compliance with all platform community guidelines"
            }
        }
    
    def _create_detailed_timeline(self, negotiated_terms: Dict[str, Any]) -> Dict[str, Any]:
        """Create detailed timeline with milestones"""
        
        timeline = negotiated_terms.get("timeline", "7 days")
        
        return {
            "total_duration": timeline,
            "content_creation_period": timeline,
            "review_period": "48 hours",
            "revision_period": "48 hours",
            "milestones": [
                {
                    "name": "Contract Execution",
                    "target_date": (datetime.now() + timedelta(days=1)).isoformat(),
                    "description": "Contract signed by both parties"
                },
                {
                    "name": "Brief & Assets Delivery",
                    "target_date": (datetime.now() + timedelta(days=2)).isoformat(),
                    "description": "Brand provides creative brief and product samples"
                },
                {
                    "name": "Content Creation",
                    "target_date": (datetime.now() + timedelta(days=5)).isoformat(),
                    "description": "Creator develops content according to brief"
                },
                {
                    "name": "Content Review",
                    "target_date": (datetime.now() + timedelta(days=7)).isoformat(),
                    "description": "Brand reviews and approves content"
                },
                {
                    "name": "Content Publishing",
                    "target_date": (datetime.now() + timedelta(days=9)).isoformat(),
                    "description": "Content goes live on creator's platforms"
                }
            ]
        }
    
    def _create_milestone_tracking(self, negotiation_state: NegotiationState) -> Dict[str, Any]:
        """Create milestone tracking system"""
        
        return {
            "tracking_id": f"ML-{negotiation_state.conversation_id}",
            "total_milestones": 5,
            "completed_milestones": 0,
            "current_milestone": "Contract Generation",
            "progress_percentage": 0,
            "estimated_completion": self._calculate_content_due_date(negotiation_state.negotiated_terms),
            "tracking_system": "automated",
            "notification_preferences": {
                "email_updates": True,
                "milestone_reminders": True,
                "deadline_alerts": True
            }
        }
    
    def _format_usage_rights(self, negotiated_terms: Dict[str, Any]) -> Dict[str, Any]:
        """Format usage rights for database storage"""
        
        usage_rights = negotiated_terms.get("usage_rights", "organic_only")
        
        rights_config = {
            "organic_only": {
                "duration_months": 12,
                "paid_advertising": False,
                "commercial_use": False,
                "sublicensing": False,
                "attribution_required": True
            },
            "paid_ads": {
                "duration_months": 6,
                "paid_advertising": True,
                "commercial_use": False,
                "sublicensing": False,
                "attribution_required": True
            },
            "commercial_use": {
                "duration_months": 12,
                "paid_advertising": True,
                "commercial_use": True,
                "sublicensing": True,
                "attribution_required": True
            }
        }
        
        return {
            "type": usage_rights,
            "details": rights_config.get(usage_rights, rights_config["organic_only"]),
            "start_date": datetime.now().isoformat(),
            "end_date": (datetime.now() + timedelta(days=365)).isoformat(),
            "geographic_scope": "Worldwide",
            "platform_scope": "All social media platforms",
            "exclusivity": False
        }
    
    def _get_compliance_requirements(self) -> Dict[str, Any]:
        """Get compliance requirements"""
        
        return {
            "ftc_disclosure": {
                "required": True,
                "methods": ["#ad", "#sponsored", "#partnership"],
                "placement": "Beginning of caption and visible in video"
            },
            "platform_compliance": {
                "instagram": "Follow Instagram branded content policies",
                "youtube": "Use YouTube paid promotion disclosure",
                "tiktok": "Include TikTok advertising disclosure",
                "twitter": "Use Twitter advertising policy compliance"
            },
            "brand_safety": {
                "content_guidelines": True,
                "competitor_restrictions": True,
                "controversial_content": "Prohibited"
            },
            "legal_requirements": {
                "age_verification": "Creator must be 18+",
                "business_registration": "Creator responsible for tax obligations",
                "insurance": "Recommended but not required"
            }
        }
    
    def _calculate_content_due_date(self, negotiated_terms: Dict[str, Any]) -> str:
        """Calculate content due date based on timeline"""
        
        timeline = negotiated_terms.get("timeline", "7 days")
        
        # Parse timeline (simple implementation)
        if "day" in timeline.lower():
            try:
                days = int(timeline.lower().split("day")[0].strip())
                due_date = datetime.now() + timedelta(days=days)
            except:
                due_date = datetime.now() + timedelta(days=7)  # Default
        else:
            due_date = datetime.now() + timedelta(days=7)  # Default
        
        return due_date.isoformat()

class ContractStatusManager:
    """
    📊 Manages contract status and workflow progression
    """
    
    STATUS_WORKFLOW = [
        "draft",
        "review",
        "sent",
        "signed",
        "active",
        "completed",
        "cancelled"
    ]
    
    @staticmethod
    def update_contract_status(contract_record: Dict[str, Any], new_status: str) -> Dict[str, Any]:
        """Update contract status with validation"""
        
        if new_status not in ContractStatusManager.STATUS_WORKFLOW:
            raise ValueError(f"Invalid status: {new_status}")
        
        contract_record["status"] = new_status
        contract_record["status_updated_at"] = datetime.now().isoformat()
        
        # Add status-specific metadata
        if new_status == "sent":
            contract_record["sent_date"] = datetime.now().isoformat()
        elif new_status == "signed":
            contract_record["signed_date"] = datetime.now().isoformat()
        elif new_status == "active":
            contract_record["activation_date"] = datetime.now().isoformat()
        elif new_status == "completed":
            contract_record["completion_date"] = datetime.now().isoformat()
        
        return contract_record