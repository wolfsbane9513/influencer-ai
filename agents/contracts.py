# agents/contracts.py
import uuid
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List

from models.campaign import CampaignData
from models.negotiation import NegotiationState

# Import settings with fallback
try:
    from config.settings import settings
except ImportError:
    from config.simple_settings import settings

logger = logging.getLogger(__name__)

class ContractAgent:
    """
    AI agent that generates contracts for successful negotiations
    """
    
    def __init__(self):
        self.contract_templates = self._load_contract_templates()
    
    def _load_contract_templates(self) -> Dict[str, str]:
        """Load contract templates"""
        return {
            "standard": """
INFLUENCER MARKETING AGREEMENT

Agreement ID: {contract_id}
Date: {contract_date}

PARTIES:
Brand: {brand_name}
Influencer: {creator_name}
Campaign: {campaign_name}

TERMS:
1. COMPENSATION: ${final_rate}
2. DELIVERABLES: {deliverables}
3. TIMELINE: {timeline}
4. USAGE RIGHTS: {usage_rights}
5. PAYMENT SCHEDULE: {payment_schedule}

DELIVERABLE SPECIFICATIONS:
{deliverable_details}

PAYMENT TERMS:
- Total Amount: ${final_rate}
- Payment Schedule: {payment_schedule}
- Payment Method: Bank transfer or digital payment

USAGE RIGHTS:
- {usage_rights_details}

TIMELINE:
- Contract Execution: {execution_date}
- Content Delivery: {delivery_date}
- Campaign Duration: {campaign_duration}

ADDITIONAL TERMS:
- Brand safety guidelines must be followed
- Content subject to brand approval
- Creator maintains editorial control within brand guidelines
- Cancellation terms: 48 hours notice with 50% payment

This agreement is binding upon signature by both parties.

Generated by InfluencerFlow AI Platform
""",
            "premium": """
PREMIUM INFLUENCER MARKETING AGREEMENT

[Similar structure but with more detailed terms for high-value creators]
"""
        }
    
    async def generate_contract(
        self,
        negotiation_state: NegotiationState,
        campaign_data: CampaignData
    ) -> Dict[str, Any]:
        """
        Generate contract for successful negotiation
        """
        try:
            logger.info(f"üìù Generating contract for {negotiation_state.creator_id}")
            
            # Generate contract ID
            contract_id = str(uuid.uuid4())[:8].upper()
            
            # Prepare contract data
            contract_data = self._prepare_contract_data(
                negotiation_state, campaign_data, contract_id
            )
            
            # Generate contract content
            contract_content = self._generate_contract_content(contract_data)
            
            # Create contract record
            contract_record = {
                "contract_id": contract_id,
                "campaign_id": campaign_data.id,
                "creator_id": negotiation_state.creator_id,
                "final_rate": negotiation_state.final_rate,
                "terms": negotiation_state.negotiated_terms,
                "deliverables": self._format_deliverables(negotiation_state.negotiated_terms),
                "payment_schedule": self._create_payment_schedule(negotiation_state),
                "contract_content": contract_content,
                "status": "draft",
                "created_at": datetime.now().isoformat(),
                "execution_date": (datetime.now() + timedelta(days=1)).isoformat(),
                "delivery_date": (datetime.now() + timedelta(days=7)).isoformat()
            }
            
            logger.info(f"‚úÖ Contract {contract_id} generated successfully")
            
            return contract_record
            
        except Exception as e:
            logger.error(f"‚ùå Contract generation failed: {e}")
            raise
    
    def _prepare_contract_data(
        self,
        negotiation_state: NegotiationState,
        campaign_data: CampaignData,
        contract_id: str
    ) -> Dict[str, Any]:
        """Prepare data for contract generation"""
        
        # Get negotiated terms
        terms = negotiation_state.negotiated_terms or {}
        deliverables = terms.get("deliverables", ["video_review", "instagram_post"])
        timeline = terms.get("timeline", "7 days")
        usage_rights = terms.get("usage_rights", "organic_only")
        payment_schedule = terms.get("payment_schedule", "50% upfront, 50% on delivery")
        
        return {
            "contract_id": contract_id,
            "contract_date": datetime.now().strftime("%Y-%m-%d"),
            "brand_name": campaign_data.brand_name,
            "creator_name": negotiation_state.creator_id,  # Would lookup actual name
            "campaign_name": f"{campaign_data.product_name} Campaign",
            "final_rate": negotiation_state.final_rate,
            "deliverables": ", ".join(deliverables),
            "timeline": timeline,
            "usage_rights": usage_rights,
            "payment_schedule": payment_schedule,
            "deliverable_details": self._generate_deliverable_details(deliverables),
            "usage_rights_details": self._generate_usage_rights_details(usage_rights),
            "execution_date": (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d"),
            "delivery_date": (datetime.now() + timedelta(days=7)).strftime("%Y-%m-%d"),
            "campaign_duration": "30 days from delivery"
        }
    
    def _generate_contract_content(self, contract_data: Dict[str, Any]) -> str:
        """Generate the actual contract content"""
        
        # Choose template based on contract value
        final_rate = contract_data.get("final_rate", 0)
        template_type = "premium" if final_rate > 5000 else "standard"
        
        template = self.contract_templates[template_type]
        
        # Format template with contract data
        contract_content = template.format(**contract_data)
        
        return contract_content
    
    def _generate_deliverable_details(self, deliverables: List[str]) -> str:
        """Generate detailed deliverable specifications"""
        
        deliverable_specs = {
            "video_review": "- Product review video (2-5 minutes)\n  - Honest opinion and demonstration\n  - High-quality production (1080p minimum)",
            "instagram_post": "- Instagram feed post with product showcase\n  - High-quality images/video\n  - Engaging caption with brand mentions",
            "instagram_story": "- Instagram story series (3-5 slides)\n  - Behind-the-scenes content\n  - Brand tag and swipe-up if available",
            "tiktok_video": "- TikTok video showcasing product\n  - Creative, platform-appropriate content\n  - Trending audio/hashtags when relevant",
            "unboxing_video": "- Unboxing experience video\n  - Genuine reactions and first impressions\n  - Clear product visibility"
        }
        
        details = []
        for deliverable in deliverables:
            if deliverable in deliverable_specs:
                details.append(deliverable_specs[deliverable])
            else:
                details.append(f"- {deliverable.replace('_', ' ').title()}")
        
        return "\n".join(details)
    
    def _generate_usage_rights_details(self, usage_rights: str) -> str:
        """Generate detailed usage rights specifications"""
        
        rights_details = {
            "organic_only": "Content may be used for organic social media posts only. No paid advertising without additional compensation.",
            "paid_ads": "Content may be used for organic posts and paid social media advertising for 3 months.",
            "commercial_use": "Full commercial usage rights including advertising, marketing materials, and website usage for 12 months.",
            "exclusive": "Exclusive usage rights - creator may not work with competing brands for 6 months."
        }
        
        return rights_details.get(usage_rights, "Standard organic usage rights apply")
    
    def _format_deliverables(self, negotiated_terms: Dict[str, Any]) -> Dict[str, Any]:
        """Format deliverables for database storage"""
        
        deliverables = negotiated_terms.get("deliverables", [])
        
        return {
            "primary_deliverables": deliverables,
            "specifications": {
                "quality": "High-quality, professional content",
                "timeline": negotiated_terms.get("timeline", "7 days"),
                "revisions": "Up to 2 minor revisions included",
                "format_requirements": "Platform-appropriate formats and dimensions"
            },
            "approval_process": {
                "draft_review": "Brand reviews draft/outline within 24 hours",
                "final_approval": "Brand approves final content within 48 hours",
                "posting_schedule": "Coordinate posting time with brand team"
            }
        }
    
    def _create_payment_schedule(self, negotiation_state: NegotiationState) -> List[Dict[str, Any]]:
        """Create detailed payment schedule"""
        
        final_rate = negotiation_state.final_rate
        payment_terms = negotiation_state.negotiated_terms.get("payment_schedule", "50% upfront, 50% on delivery")
        
        if "50% upfront" in payment_terms:
            # Split payment
            upfront_amount = final_rate * 0.5
            delivery_amount = final_rate * 0.5
            
            return [
                {
                    "milestone": "Contract Execution",
                    "amount": upfront_amount,
                    "due_date": (datetime.now() + timedelta(days=1)).isoformat(),
                    "description": "50% upfront payment upon contract signing"
                },
                {
                    "milestone": "Content Delivery",
                    "amount": delivery_amount,
                    "due_date": (datetime.now() + timedelta(days=8)).isoformat(),
                    "description": "50% final payment upon content delivery and approval"
                }
            ]
        else:
            # Full payment on delivery
            return [
                {
                    "milestone": "Content Delivery",
                    "amount": final_rate,
                    "due_date": (datetime.now() + timedelta(days=8)).isoformat(),
                    "description": "Full payment upon content delivery and approval"
                }
            ]
    
    async def generate_payment_invoice(
        self,
        contract_record: Dict[str, Any],
        milestone: str
    ) -> Dict[str, Any]:
        """Generate payment invoice for a specific milestone"""
        
        try:
            # Find the payment milestone
            payment_schedule = contract_record.get("payment_schedule", [])
            milestone_payment = None
            
            for payment in payment_schedule:
                if payment["milestone"] == milestone:
                    milestone_payment = payment
                    break
            
            if not milestone_payment:
                raise ValueError(f"Milestone '{milestone}' not found in payment schedule")
            
            # Generate invoice
            invoice_id = str(uuid.uuid4())[:8].upper()
            
            invoice = {
                "invoice_id": invoice_id,
                "contract_id": contract_record["contract_id"],
                "campaign_id": contract_record["campaign_id"],
                "creator_id": contract_record["creator_id"],
                "amount": milestone_payment["amount"],
                "milestone": milestone,
                "description": milestone_payment["description"],
                "due_date": milestone_payment["due_date"],
                "status": "pending",
                "created_at": datetime.now().isoformat()
            }
            
            logger.info(f"üìÑ Invoice {invoice_id} generated for ${milestone_payment['amount']}")
            
            return invoice
            
        except Exception as e:
            logger.error(f"‚ùå Invoice generation failed: {e}")
            raise